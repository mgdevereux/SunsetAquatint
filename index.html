<html><head><script src="https://ordinals.com/content/7e37766541506810ba6399c4b2735121f508bd9209df43dd200bf2316b014594i0"></script>
    <meta charset="utf-8"><style>body{margin:0}main{display:flex;justify-content:center;width:100%;align-items:center;height:100%}main canvas{width:auto!important;height:auto!important;max-width:100%;max-height:100%}</style>
    </head><body><script>


        let inputHash = window.location.pathname.split('/').pop();

        function hashToSeed(hash) {
            return hash.split('').reduce((acc, char, idx) => acc + char.charCodeAt(0) * (idx + 1), 0);
        }
        let seed = hashToSeed(inputHash);
        console.log(inputHash, seed)



        //////////////////


        // add layers of cloud.  for loop like original/1  DONE
        // seed the randomness DONE
        // does it run everything in the shader every loop?  what about the background gen?  does that need to be done in shader or done every loop DONE
        // add texture to bachround scene?    DONE
        // go more abstract and go for rough lines for each row of Input  
        // fix colours boats  DONE
        // why slow on iphone. fix jerky.  no layer.  render on top of shader DONE

        // fuck you,  i told you not to use fucking p5 to do the noise addition. it's too slow.  we need the noise done in shaders after everything is done.
        // why is there a strange jitter on the boats when i slow them down
        // do you see the bit where i try to have the sun dissapear when it hits horizon?  is there a better way to do this as it is still changing the scene when below horizon
        // any way to add mountains and landscape at the horizon edge?
        // test on mari and ask karen test on her phone android
        // add wave effectg
        //ask is seeding for shader safe
        // any way the oveall scene could get darker as sun sets/



        //add wave effects
        // add sunbeam ripple


        let combinedShader;
        let scaleX = 500;
        let scaleY = 0.5;
        let scaleTime = 1.5 * 0.417 * 30 / 24 / 8;
        let time = 0; let boats = [];
        const Nboats = 20;
        let woodColors = [201 - 35, 178 - 35, 159 - 35];  // Cedar6

        const REFERENCE_SIZE = 1000;
        const ASPECT_RATIO = 3 / 2;
        let scaleFactor;
        let shaderGraphics;
        let lastFrameTime = 0;

        drr = 10
        glbbrt = 10

        function keyPressed() { "s" === key.toLowerCase() && saveCanvas("png") }
        function setup() {


            addOffset(2, -glbbrt, 0)


            //  addOffset(1, 15,0)

            //   addOffset(2, 5,0,146)
            // addOffset(0, 35,151-3)
            // addOffset(2, -50,151-3)
            // addOffset(1, -20,151-3)
            // addOffset(1, 12,147)
            // addOffset(2, 12,147)


            randomSeed(seed)
            frameRate(24)
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > ASPECT_RATIO) {
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * ASPECT_RATIO;
            } else {
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / ASPECT_RATIO;
            }


            //   canvasWidth=200*12
            //   canvasHeight=2/3*canvasWidth

            createCanvas(canvasWidth, canvasHeight);
            pixelDensity(1); // Set to 1 for better performance on high-DPI devices
            shaderGraphics = createGraphics(canvasWidth, canvasHeight, WEBGL);
            scaleFactor = min(width, height) / REFERENCE_SIZE;

            combinedShader = shaderGraphics.createShader(vertexShader, fragmentShader);
            shaderGraphics.shader(combinedShader);

            let seedValue = random(1000);
            combinedShader.setUniform('u_seed', seedValue);
            combinedShader.setUniform('u_resolution', [width, height]);
            combinedShader.setUniform('u_scaleX', scaleX);
            combinedShader.setUniform('u_scaleY', scaleY);
            combinedShader.setUniform('u_scaleFactor', scaleFactor);
            combinedShader.setUniform('u_scaleTime', scaleTime);
            combinedShader.setUniform('u_cloudColor', [1, 1, 1]);
            combinedShader.setUniform('u_transparencyScaling', 1.0);
            combinedShader.setUniform('gradientPoints', gradientPoints.flat());
            combinedShader.setUniform('numPoints', gradientPoints.length);
            imsaved = 0


            requestAnimationFrame(animationLoop);
        }

        function animationLoop(currentTime) {
            // console.log(frameRate())
            const deltaTime = (currentTime - lastFrameTime) / 2000;
            lastFrameTime = currentTime;

            shaderGraphics.shader(combinedShader);
            time += 0.01;
            combinedShader.setUniform('u_time', time);
            shaderGraphics.rect(-width / 2, -height / 2, width, height);

            image(shaderGraphics, 0, 0);


            requestAnimationFrame(animationLoop);
            //    imsaved==0?(saveCanvas(),imsaved=1):0
        }
        const vertexShader = `
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;
        void main() {
          vTexCoord = aTexCoord;
          vec4 positionVec4 = vec4(aPosition, 1.0);
          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
          gl_Position = positionVec4;
        }`;

        const fragmentShader = `
        precision mediump float;
        varying vec2 vTexCoord;
        uniform float u_scaleX;
        uniform float u_scaleY;
        uniform float u_scaleFactor;
        uniform float u_scaleTime;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cloudColor;
        uniform float u_transparencyScaling;
        uniform vec3 gradientPoints[300];
        uniform int numPoints;
        uniform float u_seed;
        
        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
        
        vec2 hash( vec2 p ) {
            p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }
        
        float noise( in vec2 p ) {
            const float K1 = 0.366025404;
            const float K2 = 0.211324865;
            vec2 i = floor(p + (p.x+p.y)*K1);
            vec2 a = p - i + (i.x+i.y)*K2;
            vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
            vec2 b = a - o + K2;
            vec2 c = a - 1.0 + 2.0*K2;
            vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            return dot(n, vec3(70.0));
        }
        
        float fbm(vec2 n) {
            float total = 0.0, amplitude = 0.1;
            for (int i = 0; i < 2; i++) {
                total += noise(n+u_seed) * amplitude;
                n = m * n;
                amplitude *= 0.4;
            }
            return 5.*total;
        }
        
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        
        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }
        
        vec3 getGradientColor(float y) {
            float indexFloat = y * float(numPoints - 1);
            int indexLower = int(floor(indexFloat));
            int indexUpper = int(ceil(indexFloat));
            float t = fract(indexFloat);
        
            vec3 colorLower = vec3(0.0);
            vec3 colorUpper = vec3(0.0);
        
            for (int i = 0; i < 300; i++) {
                if (i == indexLower) colorLower = gradientPoints[i] / 255.0;
                if (i == indexUpper) {
                    colorUpper = gradientPoints[i] / 255.0;
                    break;
                }
            }
        
            t = smoothstep(0.0, 1.0, t);
        
            float noise = fract(sin(dot(vTexCoord, vec2(12.9898, 78.233))) * 43758.5453);
            
            return 1.000005031*hsv2rgb(mix(colorLower, colorUpper, t) + 5.0 * (noise - 0.5) / 255.0);
        }
        
        void main() {
  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); // Simple red color
}`;

        function addOffset(elementIndex, offset, start, stop = gradientPoints.length) {
            stop = Math.min(stop, gradientPoints.length);
            for (let i = start; i < stop; i++) {
                gradientPoints[i][elementIndex] += offset;
                gradientPoints[i][elementIndex] = constrain(gradientPoints[i][elementIndex], 0, 255);
            }
        }
        const gradientPoints = [
            [148, 31, 221], [148, 31, 221], [148, 30, 222], [148, 29, 222], [148, 29, 222],
            [148, 28, 222], [147, 28, 222], [147, 28, 222], [147, 29, 222], [147, 28, 223],
            [147, 28, 223], [146, 29, 223], [146, 29, 224], [146, 29, 224], [146, 29, 224],
            [146, 30, 224], [146, 30, 225], [145, 31, 225], [145, 31, 226], [145, 31, 226],
            [145, 32, 226], [145, 32, 226], [144, 32, 227], [144, 32, 227], [144, 32, 227],
            [144, 31, 228], [144, 28, 227], [145, 27, 227], [145, 26, 227], [144, 25, 227],
            [144, 25, 227], [144, 24, 228], [144, 24, 228], [143, 23, 228], [143, 23, 228],
            [143, 22, 228], [143, 22, 228], [142, 22, 228], [141, 23, 228], [141, 24, 228],
            [140, 26, 229], [139, 27, 229], [139, 27, 229], [139, 28, 229], [138, 28, 229],
            [138, 29, 229], [138, 29, 229], [137, 29, 230], [137, 29, 230], [137, 29, 230],
            [136, 29, 230], [136, 28, 230], [136, 27, 230], [136, 27, 230], [136, 26, 230],
            [135, 26, 230], [134, 25, 230], [133, 23, 230], [132, 22, 229], [131, 21, 229],
            [131, 20, 229], [129, 19, 229], [128, 18, 229], [127, 17, 229], [125, 16, 229],
            [123, 15, 230], [122, 15, 230], [121, 15, 230], [119, 15, 230], [118, 14, 231],
            [115, 14, 231], [113, 14, 231], [111, 13, 232], [108, 13, 232], [106, 13, 232],
            [102, 12, 233], [99, 12, 233], [96, 12, 234], [92, 11, 234], [89, 11, 235],
            [83, 11, 235], [76, 12, 236], [71, 12, 235], [66, 13, 236], [61, 14, 236],
            [59, 15, 236], [54, 16, 236], [52, 16, 237], [50, 18, 237], [47, 19, 237],
            [45, 20, 237], [42, 22, 238], [40, 23, 239], [39, 25, 239], [37, 28, 241],
            [36, 30, 242], [34, 32, 243], [34, 34, 243], [32, 36, 244], [31, 37, 245],
            [30, 40, 246], [30, 41, 247], [29, 44, 247], [29, 45, 248], [28, 48, 249],
            [27, 50, 250], [26, 53, 251], [25, 55, 252], [25, 57, 251], [25, 58, 251],
            [24, 60, 251], [24, 62, 251], [23, 63, 251], [23, 65, 251], [22, 67, 252],
            [22, 69, 252], [21, 71, 253], [20, 72, 253], [19, 74, 254], [18, 75, 254],
            [17, 76, 255], [17, 77, 254], [16, 78, 253], [16, 77, 251], [16, 75, 247],
            [15, 73, 245], [15, 72, 242], [15, 71, 240], [14, 70, 237], [13, 68, 235],
            [13, 67, 232], [12, 65, 230], [11, 62, 227], [11, 61, 224], [10, 58, 221],
            [10, 55, 217], [10, 50, 212], [10, 44, 206], [11, 36, 199], [13, 31, 194],
            [21, 19, 184], [27, 15, 179], [30, 12, 177], [33, 11, 176], [38, 11, 168],
            [46, 14, 150], [49, 17, 136], [21, 32, 151], [17, 45, 188], [19, 46, 175],
            [19, 51, 204], [21, 50, 202], [23, 46, 197], [22, 48, 200], [25, 44, 194],
            [25, 45, 194], [23, 47, 198], [23, 48, 198], [22, 50, 200], [21, 51, 201],
            [20, 54, 203], [19, 56, 204], [18, 57, 204], [19, 58, 204], [19, 58, 203],
            [19, 58, 202], [19, 59, 203], [18, 60, 203], [17, 62, 204], [17, 64, 205],
            [16, 66, 206], [17, 69, 201], [17, 68, 191], [18, 67, 190], [19, 66, 177],
            [22, 61, 174], [21, 66, 186], [20, 70, 198], [20, 69, 202], [20, 68, 202],
            [21, 66, 200], [22, 65, 199], [23, 63, 195], [23, 62, 193], [23, 62, 188]];







    </script></body></html>
