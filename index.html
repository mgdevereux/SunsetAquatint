<html><head><script src="https://ordinals.com/content/b6a50f5ba932b0ea7f652d9d28e59eced47bc6f8376c25e02d8b3457bb60ac8fi0"></script>
    <meta charset="utf-8"><style>body{margin:0}main{display:flex;justify-content:center;width:100%;align-items:center;height:100%}main canvas{width:auto!important;height:auto!important;max-width:100%;max-height:100%}</style>
    </head><body><script>


        let inputHash = window.location.pathname.split('/').pop();

        function hashToSeed(hash) {
            return hash.split('').reduce((acc, char, idx) => acc + char.charCodeAt(0) * (idx + 1), 0);
        }
        let seed = hashToSeed(inputHash);
        console.log(inputHash, seed)



        //////////////////


        // add layers of cloud.  for loop like original/1  DONE
        // seed the randomness DONE
        // does it run everything in the shader every loop?  what about the background gen?  does that need to be done in shader or done every loop DONE
        // add texture to bachround scene?    DONE
        // go more abstract and go for rough lines for each row of Input  
        // fix colours boats  DONE
        // why slow on iphone. fix jerky.  no layer.  render on top of shader DONE

        // fuck you,  i told you not to use fucking p5 to do the noise addition. it's too slow.  we need the noise done in shaders after everything is done.
        // why is there a strange jitter on the boats when i slow them down
        // do you see the bit where i try to have the sun dissapear when it hits horizon?  is there a better way to do this as it is still changing the scene when below horizon
        // any way to add mountains and landscape at the horizon edge?
        // test on mari and ask karen test on her phone android
        // add wave effectg
        //ask is seeding for shader safe
        // any way the oveall scene could get darker as sun sets/



        //add wave effects
        // add sunbeam ripple


        let combinedShader;
        let scaleX = 500;
        let scaleY = 0.5;
        let scaleTime = 1.5 * 0.417 * 30 / 24 / 8;
        let time = 0; let boats = [];
        const Nboats = 20;
        let woodColors = [201 - 35, 178 - 35, 159 - 35];  // Cedar6

        const REFERENCE_SIZE = 1000;
        const ASPECT_RATIO = 3 / 2;
        let scaleFactor;
        let shaderGraphics;
        let lastFrameTime = 0;

        drr = 10
        glbbrt = 10

        function keyPressed() { "s" === key.toLowerCase() && saveCanvas("png") }
        function setup() {


            addOffset(2, -glbbrt, 0)


            //  addOffset(1, 15,0)

            //   addOffset(2, 5,0,146)
            // addOffset(0, 35,151-3)
            // addOffset(2, -50,151-3)
            // addOffset(1, -20,151-3)
            // addOffset(1, 12,147)
            // addOffset(2, 12,147)


            randomSeed(seed)
            frameRate(24)
            let canvasWidth, canvasHeight;
            if (windowWidth / windowHeight > ASPECT_RATIO) {
                canvasHeight = windowHeight;
                canvasWidth = canvasHeight * ASPECT_RATIO;
            } else {
                canvasWidth = windowWidth;
                canvasHeight = canvasWidth / ASPECT_RATIO;
            }


            //   canvasWidth=200*12
            //   canvasHeight=2/3*canvasWidth

            createCanvas(canvasWidth, canvasHeight);
            pixelDensity(1); // Set to 1 for better performance on high-DPI devices
            shaderGraphics = createGraphics(canvasWidth, canvasHeight, WEBGL);
            scaleFactor = min(width, height) / REFERENCE_SIZE;

            combinedShader = shaderGraphics.createShader(vertexShader, fragmentShader);
            shaderGraphics.shader(combinedShader);

            let seedValue = random(1000);
            combinedShader.setUniform('u_seed', seedValue);
            combinedShader.setUniform('u_resolution', [width, height]);
            combinedShader.setUniform('u_scaleX', scaleX);
            combinedShader.setUniform('u_scaleY', scaleY);
            combinedShader.setUniform('u_scaleFactor', scaleFactor);
            combinedShader.setUniform('u_scaleTime', scaleTime);
            combinedShader.setUniform('u_cloudColor', [1, 1, 1]);
            combinedShader.setUniform('u_transparencyScaling', 1.0);
            combinedShader.setUniform('gradientPoints', gradientPoints.flat());
            combinedShader.setUniform('numPoints', gradientPoints.length);
            imsaved = 0


            requestAnimationFrame(animationLoop);
        }

        function animationLoop(currentTime) {
            // console.log(frameRate())
            const deltaTime = (currentTime - lastFrameTime) / 2000;
            lastFrameTime = currentTime;

            shaderGraphics.shader(combinedShader);
            time += 0.01;
            combinedShader.setUniform('u_time', time);
            shaderGraphics.rect(-width / 2, -height / 2, width, height);

            image(shaderGraphics, 0, 0);


            requestAnimationFrame(animationLoop);
            //    imsaved==0?(saveCanvas(),imsaved=1):0
        }
        const vertexShader = `
        attribute vec3 aPosition;
        attribute vec2 aTexCoord;
        varying vec2 vTexCoord;
        void main() {
          vTexCoord = aTexCoord;
          vec4 positionVec4 = vec4(aPosition, 1.0);
          positionVec4.xy = positionVec4.xy * 2.0 - 1.0;
          gl_Position = positionVec4;
        }`;

        const fragmentShader = `
        precision lowp float;
        varying vec2 vTexCoord;
        uniform float u_scaleX;
        uniform float u_scaleY;
        uniform float u_scaleFactor;
        uniform float u_scaleTime;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec3 u_cloudColor;
        uniform float u_transparencyScaling;
        uniform vec3 gradientPoints[300];
        uniform int numPoints;
        uniform float u_seed;
        
        const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );
        
        vec2 hash( vec2 p ) {
            p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));
            return -1.0 + 2.0*fract(sin(p)*43758.5453123);
        }
        
        float noise( in vec2 p ) {
            const float K1 = 0.366025404;
            const float K2 = 0.211324865;
            vec2 i = floor(p + (p.x+p.y)*K1);
            vec2 a = p - i + (i.x+i.y)*K2;
            vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
            vec2 b = a - o + K2;
            vec2 c = a - 1.0 + 2.0*K2;
            vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
            vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));
            return dot(n, vec3(70.0));
        }
        
        float fbm(vec2 n) {
            float total = 0.0, amplitude = 0.1;
            for (int i = 0; i < 2; i++) {
                total += noise(n+u_seed) * amplitude;
                n = m * n;
                amplitude *= 0.4;
            }
            return 5.*total;
        }
        
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        
        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }
        
        vec3 getGradientColor(float y) {
            float indexFloat = y * float(numPoints - 1);
            int indexLower = int(floor(indexFloat));
            int indexUpper = int(ceil(indexFloat));
            float t = fract(indexFloat);
        
            vec3 colorLower = vec3(0.0);
            vec3 colorUpper = vec3(0.0);
        
            for (int i = 0; i < 300; i++) {
                if (i == indexLower) colorLower = gradientPoints[i] / 255.0;
                if (i == indexUpper) {
                    colorUpper = gradientPoints[i] / 255.0;
                    break;
                }
            }
        
            t = smoothstep(0.0, 1.0, t);
        
            float noise = fract(sin(dot(vTexCoord, vec2(12.9898, 78.233))) * 43758.5453);
            
            return 1.000005031*hsv2rgb(mix(colorLower, colorUpper, t) + 5.0 * (noise - 0.5) / 255.0);
        }
        
        void main() {
    vec2 p = vTexCoord * u_resolution / u_resolution.y;
       vec2 p3 = vTexCoord * u_resolution / u_resolution.y;
    float time = u_time * u_scaleTime*1.;  //CHANGE
    float xs = u_scaleX;

    p += vec2(0.351, 0.03130) * time;

    float st1 = 1./3.*8.0 * fbm(p * xs * 0.0025 + vec2(time, time));
    float dst1 = 1./3.*fbm(p * xs * 0.025 + vec2(time, time));
    float st2 = 1./3.*8.0 * fbm(p * xs * 0.00125 + vec2(time * 1.5, time * 1.5));
    float dst2 = 1./3.*fbm(p * xs * 0.0125 + vec2(time * 0.75, time * 0.75));
    // float nss2 = 1./6.*1.5 * fbm((p + vec2(st2, dst2)) * xs * 0.005 + vec2(time, time));
            // float nss1 = 1./3.*fbm((p + vec2(st1, dst1)) * xs * 0.0001 + vec2(time, time));
            // float rgh = fbm(p * xs * 0.00166667 + vec2(time, time)) - 0.3;
            // float bpd = 1./3.*fbm(p * xs * 0.05 + vec2(time, time));
            // float bmp = fbm((p + vec2(0.0, 2.0 * bpd)) * xs * 0.002 + vec2(time, time));
            // float cloudValue = 5.*(st1 + dst1  + st2 + dst2 ) / 6.0 + (rgh * bpd) * 0.5+ nss2+ nss1;


            
    float cloudValue = .75075 * (st1 + dst1) + 0.5 * (st2 + dst2);


    cloudValue = clamp(cloudValue, 0.0, 1.0);

    vec3 cloudColor = u_cloudColor;
    vec3 backgroundColor = getGradientColor(1.0 - vTexCoord.y);

    float fadeStart = 0.7;
    float fadeEnd = 0.13;
    float fadeFactor = smoothstep(fadeEnd, fadeStart, vTexCoord.y);

    float alpha = u_transparencyScaling * cloudValue * fadeFactor;
    alpha = smoothstep(0.1, 0.9, alpha);
    vec2 p2 = vTexCoord * u_resolution / u_resolution.y;
    p2 += vec2(-0.231010, -0.200) ;
    p2 += vec2(-0.010, 0.030) * time*10./2.;

    vec3 finalColor = mix(backgroundColor, cloudColor, .85*alpha);
    // Mountain generation
    float horizonCenter = 0.254352;
    float horizonWidth = 0.102; // Adjust this value to control mountain height
    float mountainNoise = fbm(vec2(p3.x * 1.0, u_seed)); // Use fbm for more natural-looking mountains
    //CHANGE
    // float horizonWidth = 0.102/1.11; // Adjust this value to control mountain height
    //  float mountainNoise = .021*fbm(vec2(p3.x * 100.0, u_seed))+.1*fbm(vec2(p3.x * 10.0, u_seed))+fbm(vec2(p3.x * 1.0, u_seed)); // Use fbm for more natural-looking mountains
   
    float mountainHeight = horizonCenter + mountainNoise * horizonWidth;
    if (p3.y < mountainHeight && p3.y > horizonCenter - horizonWidth * 0.5) {
        float t = (p3.y - (horizonCenter - horizonWidth * 0.5)) / (mountainHeight - (horizonCenter - horizonWidth * 0.5));
        vec3 mountainColor = mix(vec3(0.1, 0.1, 0.1), backgroundColor, t * t); // Smooth transition
        finalColor = mix(finalColor, mountainColor, smoothstep(0.0, 1.0, t));
    }
    float sunGlow = (20.*.8643-time)*0.0121015/20. / length(p2 - vec2(0.5, 0.2));
    if (p3.y > mountainHeight) {
        finalColor += vec3(1.0, 0.6, 0.2) * sunGlow;
    }

  
       // Brighter and narrower beam above sun
    vec2 p4 = vTexCoord * u_resolution / u_resolution.y;
    p4 += vec2(-0.231010, 0.5100) ;
    p4 += vec2(-0.010, 0.030) * time*10./2.;

    if(time<1.13)
    {
    float beamGlow = (20.*.8643-15.*time)*0.021221015/3. / length(p4 - vec2(0.5, 0.0));  //CHANGE
    float beamWidth = 0.2052;
    float beamIntensity = smoothstep(beamWidth, 0.0, abs(p4.x - 0.5));
    
    if (p3.y < .192034) {
        finalColor += vec3(1.0, 0.6, 0.2) * beamGlow * beamIntensity * smoothstep(0.2, 0.6, p4.y) * 2.0;
    }
}
    float noise = fract(sin(dot(vTexCoord, vec2(12.9898, 78.233))) * 43758.5453);
    float noiseStrength = 0.3502/3. * pow(u_scaleFactor, 0.7);  //CHANGE
    finalColor += noiseStrength * (noise - 0.5);

    float darknessScale = max(0.94875, 1.0 - time * 0.05);  //CHANGE
    finalColor *= darknessScale;

    gl_FragColor = vec4(finalColor, 1.0);
}`;

        function addOffset(elementIndex, offset, start, stop = gradientPoints.length) {
            stop = Math.min(stop, gradientPoints.length);
            for (let i = start; i < stop; i++) {
                gradientPoints[i][elementIndex] += offset;
                gradientPoints[i][elementIndex] = constrain(gradientPoints[i][elementIndex], 0, 255);
            }
        }
        const gradientPoints = [
            [148, 31, 221], [148, 31, 221], [148, 30, 222], [148, 29, 222], [148, 29, 222],
            [148, 28, 222], [147, 28, 222], [147, 28, 222], [147, 29, 222], [147, 28, 223],
            [147, 28, 223], [146, 29, 223], [146, 29, 224], [146, 29, 224], [146, 29, 224],
            [146, 30, 224], [146, 30, 225], [145, 31, 225], [145, 31, 226], [145, 31, 226],
            [145, 32, 226], [145, 32, 226], [144, 32, 227], [144, 32, 227], [144, 32, 227],
            [144, 31, 228], [144, 28, 227], [145, 27, 227], [145, 26, 227], [144, 25, 227],
            [144, 25, 227], [144, 24, 228], [144, 24, 228], [143, 23, 228], [143, 23, 228],
            [143, 22, 228], [143, 22, 228], [142, 22, 228], [141, 23, 228], [141, 24, 228],
            [140, 26, 229], [139, 27, 229], [139, 27, 229], [139, 28, 229], [138, 28, 229],
            [138, 29, 229], [138, 29, 229], [137, 29, 230], [137, 29, 230], [137, 29, 230],
            [136, 29, 230], [136, 28, 230], [136, 27, 230], [136, 27, 230], [136, 26, 230],
            [135, 26, 230], [134, 25, 230], [133, 23, 230], [132, 22, 229], [131, 21, 229],
            [131, 20, 229], [129, 19, 229], [128, 18, 229], [127, 17, 229], [125, 16, 229],
            [123, 15, 230], [122, 15, 230], [121, 15, 230], [119, 15, 230], [118, 14, 231],
            [115, 14, 231], [113, 14, 231], [111, 13, 232], [108, 13, 232], [106, 13, 232],
            [102, 12, 233], [99, 12, 233], [96, 12, 234], [92, 11, 234], [89, 11, 235],
            [83, 11, 235], [76, 12, 236], [71, 12, 235], [66, 13, 236], [61, 14, 236],
            [59, 15, 236], [54, 16, 236], [52, 16, 237], [50, 18, 237], [47, 19, 237],
            [45, 20, 237], [42, 22, 238], [40, 23, 239], [39, 25, 239], [37, 28, 241],
            [36, 30, 242], [34, 32, 243], [34, 34, 243], [32, 36, 244], [31, 37, 245],
            [30, 40, 246], [30, 41, 247], [29, 44, 247], [29, 45, 248], [28, 48, 249],
            [27, 50, 250], [26, 53, 251], [25, 55, 252], [25, 57, 251], [25, 58, 251],
            [24, 60, 251], [24, 62, 251], [23, 63, 251], [23, 65, 251], [22, 67, 252],
            [22, 69, 252], [21, 71, 253], [20, 72, 253], [19, 74, 254], [18, 75, 254],
            [17, 76, 255], [17, 77, 254], [16, 78, 253], [16, 77, 251], [16, 75, 247],
            [15, 73, 245], [15, 72, 242], [15, 71, 240], [14, 70, 237], [13, 68, 235],
            [13, 67, 232], [12, 65, 230], [11, 62, 227], [11, 61, 224], [10, 58, 221],
            [10, 55, 217], [10, 50, 212], [10, 44, 206], [11, 36, 199], [13, 31, 194],
            [21, 19, 184], [27, 15, 179], [30, 12, 177], [33, 11, 176], [38, 11, 168],
            [46, 14, 150], [49, 17, 136], [21, 32, 151], [17, 45, 188], [19, 46, 175],
            [19, 51, 204], [21, 50, 202], [23, 46, 197], [22, 48, 200], [25, 44, 194],
            [25, 45, 194], [23, 47, 198], [23, 48, 198], [22, 50, 200], [21, 51, 201],
            [20, 54, 203], [19, 56, 204], [18, 57, 204], [19, 58, 204], [19, 58, 203],
            [19, 58, 202], [19, 59, 203], [18, 60, 203], [17, 62, 204], [17, 64, 205],
            [16, 66, 206], [17, 69, 201], [17, 68, 191], [18, 67, 190], [19, 66, 177],
            [22, 61, 174], [21, 66, 186], [20, 70, 198], [20, 69, 202], [20, 68, 202],
            [21, 66, 200], [22, 65, 199], [23, 63, 195], [23, 62, 193], [23, 62, 188]];







    </script></body></html>
